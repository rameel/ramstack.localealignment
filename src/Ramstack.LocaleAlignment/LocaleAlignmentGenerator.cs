using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Ramstack.LocaleAlignment;

[Generator]
file sealed class LocaleAlignmentGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context) =>
        context.RegisterPostInitializationOutput(GenerateLocaleInitializer);

    private static void GenerateLocaleInitializer(IncrementalGeneratorPostInitializationContext context)
    {
        const string Source = """
            // <auto-generated/>

            using System;
            using System.Globalization;
            using System.Runtime.CompilerServices;

            #nullable enable

            file static class CultureInfoInitializer
            {
                [ModuleInitializer]
                public static void Initialize()
                {
                    try
                    {
                        InitializeCore();
                    }
                    catch
                    {
                        // Ignore errors
                    }
                }

                private static void InitializeCore()
                {
                    if (!OperatingSystem.IsWindows() && !IsGlobalizationInvariant())
                    {
                        //
                        // LC_MONETARY must be processed after LC_NUMERIC to prevent LC_NUMERIC
                        // from overwriting currency-specific formatting overrides.
                        //

                        CultureInfo? specific = null;
                        specific = TrySet("LC_NUMERIC", specific);
                        specific = TrySetMonetary(specific);
                        specific = TrySet("LC_TIME", specific);

                        if (specific is not null)
                        {
                            CultureInfo.CurrentCulture = CultureInfo.ReadOnly(specific);
                            CultureInfo.CurrentUICulture = CultureInfo.CurrentCulture;
                            CultureInfo.DefaultThreadCurrentCulture = CultureInfo.CurrentCulture;
                            CultureInfo.DefaultThreadCurrentUICulture = CultureInfo.CurrentCulture;
                        }
                    }

                    static CultureInfo? TrySet(string variable, CultureInfo? specific)
                    {
                        var ci = GetCultureInfoFromEnvironment(variable);
                        if (ReferenceEquals(ci, CultureInfo.CurrentCulture))
                            return specific;

                        specific ??= (CultureInfo)CultureInfo.CurrentCulture.Clone();
                        switch (variable)
                        {
                            case "LC_NUMERIC":
                                specific.NumberFormat = ci.NumberFormat;
                                break;

                            case "LC_TIME":
                                specific.DateTimeFormat = ci.DateTimeFormat;
                                break;
                        }

                        return specific;
                    }

                    static CultureInfo? TrySetMonetary(CultureInfo? specific)
                    {
                        var monetary = GetCultureInfoFromEnvironment("LC_MONETARY");

                        if (!ReferenceEquals(monetary, CultureInfo.CurrentCulture))
                            specific ??= (CultureInfo)CultureInfo.CurrentCulture.Clone();

                        // Restore currency from base culture if overwritten by LC_NUMERIC,
                        // or apply new currency settings if LC_MONETARY differs from base
                        if (specific is not null)
                        {
                            specific.NumberFormat = (NumberFormatInfo)specific.NumberFormat.Clone();
                            specific.NumberFormat.CurrencySymbol = monetary.NumberFormat.CurrencySymbol;
                            specific.NumberFormat.CurrencyDecimalDigits = monetary.NumberFormat.CurrencyDecimalDigits;
                            specific.NumberFormat.CurrencyDecimalSeparator = monetary.NumberFormat.CurrencyDecimalSeparator;
                            specific.NumberFormat.CurrencyGroupSeparator = monetary.NumberFormat.CurrencyGroupSeparator;
                            specific.NumberFormat.CurrencyGroupSizes = monetary.NumberFormat.CurrencyGroupSizes;
                            specific.NumberFormat.CurrencyNegativePattern = monetary.NumberFormat.CurrencyNegativePattern;
                            specific.NumberFormat.CurrencyPositivePattern = monetary.NumberFormat.CurrencyPositivePattern;
                        }

                        return specific;
                    }

                    static CultureInfo GetCultureInfoFromEnvironment(string variable)
                    {
                        var name = Environment.GetEnvironmentVariable(variable)?.Trim();
                        if (string.IsNullOrEmpty(name))
                            return CultureInfo.CurrentCulture;

                        name = ToBcp47(name);
                        if (string.Equals(name, CultureInfo.CurrentCulture.Name, StringComparison.OrdinalIgnoreCase))
                            return CultureInfo.CurrentCulture;

                        return CultureInfo.GetCultureInfo(name);
                    }

                    static string ToBcp47(string posix)
                    {
                        //
                        // Converts a POSIX-style locale string (e.g., "ff_CM.UTF-8@latin") to
                        // a BCP-47 compliant culture name (e.g., "ff-Latn-CM").
                        //

                        if (posix.AsSpan().IndexOfAny('.', '_', '@') < 0)
                            return posix;

                        // Format:
                        // language[_territory][.codeset][@modifier]
                        //
                        // en_IE.UTF-8@euro - full
                        // en_IE.UTF-8      - without modifier
                        // en_IE@euro       - without codeset
                        // en_IE            - minimal

                        var di = posix.IndexOf('.');
                        if (di < 0)
                            di = posix.Length;

                        var ai = posix.IndexOf('@');
                        if (ai < 0)
                            ai = posix.Length;

                        var name = posix.AsSpan(0, Math.Min(di, ai));
                        var modifier = posix.AsSpan(Math.Min(ai + 1, posix.Length));

                        if (!modifier.IsEmpty)
                        {
                            modifier = modifier switch
                            {
                                // Scripts
                                "arabic" => "Arab",
                                "cyrillic" => "Cyrl",
                                "devanagari" => "Deva",
                                "latin" => "Latn",
                                // "adlam" => "Adlm",
                                // "bengali" => "Beng",
                                // "gurmukhi" => "Guru",
                                // "olchiki" => "Olck",
                                // "orya" or "odia" => "Orya",
                                // "telugu" => "Telu",
                                // "tifinagh" => "Tfng",
                                // "vai" => "Vaii",

                                // Variants
                                "valencia" => "valencia",

                                // Skip
                                _ => ""
                            };
                        }

                        var buffer = posix.Length > 32
                            ? new char[posix.Length]
                            : stackalloc char[32];

                        if (modifier.IsEmpty)
                        {
                            name.TryCopyTo(buffer);
                            buffer = buffer.Slice(0, name.Length);
                        }
                        else
                        {
                            //
                            // language-modifier-territory
                            //
                            var index = name.IndexOf('_');
                            if (index > 0 && modifier.Length == 4 && (uint)modifier[0] - 'A' <= 'Z' - 'A')
                            {
                                name.Slice(0, index).TryCopyTo(buffer);
                                buffer[index] = '-';

                                modifier.TryCopyTo(buffer.Slice(index + 1));
                                buffer[index + 1 + modifier.Length] = '-';

                                name.Slice(index + 1).TryCopyTo(buffer.Slice(index + 2 + modifier.Length));
                                buffer = buffer.Slice(0, name.Length + modifier.Length + 1);
                            }
                            else
                            {
                                //
                                // language-modifier
                                //
                                name.TryCopyTo(buffer);
                                buffer[name.Length] = '-';
                                modifier.TryCopyTo(buffer.Slice(name.Length + 1));
                                buffer = buffer.Slice(0, name.Length + 1 + modifier.Length);
                            }
                        }

                        #if NET8_0_OR_GREATER
                        buffer.Replace('_', '-');
                        #else
                        for (var i = 0; i < buffer.Length; i++)
                            if (buffer[i] == '_')
                                buffer[i] = '-';
                        #endif

                        // create string
                        posix = new string(buffer);
                        return posix;
                    }

                    static bool IsGlobalizationInvariant()
                    {
                        // https://github.com/dotnet/runtime/blob/8fafcb3251a3d2ccde36612a2eab47e9ae8ebe2b/src/libraries/System.Private.CoreLib/src/System/Globalization/GlobalizationMode.cs

                        if (AppContext.TryGetSwitch("System.Globalization.Invariant", out var isInvariant) && isInvariant)
                            return true;

                        var value = Environment.GetEnvironmentVariable("DOTNET_SYSTEM_GLOBALIZATION_INVARIANT");
                        if (value == "1" || string.Equals(value, "true", StringComparison.OrdinalIgnoreCase))
                            return true;

                        try
                        {
                            // Starting in .NET 6, creating or resolving cultures other than the invariant one
                            // throws an exception except when "PredefinedCulturesOnly" is set to false
                            // (in this case, NativeName contains "Invariant" for all returned cultures).
                            //
                            // https://learn.microsoft.com/en-us/dotnet/core/compatibility/globalization/6.0/culture-creation-invariant-mode
                            // https://learn.microsoft.com/en-us/dotnet/core/runtime-config/globalization#predefined-cultures

                            return CultureInfo.GetCultureInfo("en-US").NativeName.Contains("Invariant", StringComparison.Ordinal);
                        }
                        catch (CultureNotFoundException)
                        {
                            return true;
                        }
                    }
                }
            }

            """;

        context.AddSource("CultureInfoInitializer.g.cs", SourceText.From(Source, Encoding.UTF8));
    }
}
