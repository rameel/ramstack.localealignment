using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace Ramstack.LocaleAlignment.Generator;

[Generator]
public sealed class LocaleAlignmentGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var version = context.CompilationProvider.Select((c, _) => c is CSharpCompilation csharp ? (LanguageVersion?)csharp.LanguageVersion : null);
        context.RegisterSourceOutput(version, GenerateLocaleInitializer);
    }

    private static void GenerateLocaleInitializer(SourceProductionContext context, LanguageVersion? version)
    {
        if (version is null)
            return;

        var modifier = version == LanguageVersion.CSharp10 ? "internal" : "file";

        var source = $$"""
            // <auto-generated />

            #nullable enable

            [EditorBrowsable(EditorBrowsableState.Never)]
            {{modifier}} static class LocaleAlignment
            {
                [ModuleInitializer]
                public static void Apply()
                {
                    try
                    {
                        ApplyCore();
                    }
                    catch
                    {
                        // Ignore errors
                    }
                }

                private static void ApplyCore()
                {
                    if (!OperatingSystem.IsWindows() && !IsGlobalizationInvariant())
                    {
                        //
                        // LC_MONETARY must be processed after LC_NUMERIC to prevent LC_NUMERIC
                        // from overwriting currency-specific formatting overrides.
                        //

                        CultureInfo? specific = null;
                        specific = TrySet("LC_NUMERIC", specific);
                        specific = TrySetMonetary(specific);
                        specific = TrySet("LC_TIME", specific);

                        if (specific is not null)
                        {
                            CultureInfo.CurrentCulture = CultureInfo.ReadOnly(specific);
                            CultureInfo.CurrentUICulture = CultureInfo.CurrentCulture;
                            CultureInfo.DefaultThreadCurrentCulture = CultureInfo.CurrentCulture;
                            CultureInfo.DefaultThreadCurrentUICulture = CultureInfo.CurrentCulture;
                        }
                    }

                    static CultureInfo? TrySet(string variable, CultureInfo? specific)
                    {
                        var ci = GetCultureInfoFromEnvironment(variable);
                        if (ReferenceEquals(ci, CultureInfo.CurrentCulture))
                            return specific;

                        specific ??= (CultureInfo)CultureInfo.CurrentCulture.Clone();
                        switch (variable)
                        {
                            case "LC_NUMERIC":
                                specific.NumberFormat = ci.NumberFormat;
                                break;

                            case "LC_TIME":
                                specific.DateTimeFormat = ci.DateTimeFormat;
                                break;
                        }

                        return specific;
                    }

                    static CultureInfo? TrySetMonetary(CultureInfo? specific)
                    {
                        var monetary = GetCultureInfoFromEnvironment("LC_MONETARY");

                        if (!ReferenceEquals(monetary, CultureInfo.CurrentCulture))
                            specific ??= (CultureInfo)CultureInfo.CurrentCulture.Clone();

                        // Restore currency from base culture if overwritten by LC_NUMERIC,
                        // or apply new currency settings if LC_MONETARY differs from base
                        if (specific is not null)
                        {
                            specific.NumberFormat = (NumberFormatInfo)specific.NumberFormat.Clone();
                            specific.NumberFormat.CurrencySymbol = monetary.NumberFormat.CurrencySymbol;
                            specific.NumberFormat.CurrencyDecimalDigits = monetary.NumberFormat.CurrencyDecimalDigits;
                            specific.NumberFormat.CurrencyDecimalSeparator = monetary.NumberFormat.CurrencyDecimalSeparator;
                            specific.NumberFormat.CurrencyGroupSeparator = monetary.NumberFormat.CurrencyGroupSeparator;
                            specific.NumberFormat.CurrencyGroupSizes = monetary.NumberFormat.CurrencyGroupSizes;
                            specific.NumberFormat.CurrencyNegativePattern = monetary.NumberFormat.CurrencyNegativePattern;
                            specific.NumberFormat.CurrencyPositivePattern = monetary.NumberFormat.CurrencyPositivePattern;
                        }

                        return specific;
                    }

                    static CultureInfo GetCultureInfoFromEnvironment(string variable)
                    {
                        var name = Environment.GetEnvironmentVariable(variable)?.Trim();
                        if (string.IsNullOrEmpty(name))
                            return CultureInfo.CurrentCulture;

                        name = ToBcp47(name);
                        if (string.Equals(name, CultureInfo.CurrentCulture.Name, StringComparison.OrdinalIgnoreCase))
                            return CultureInfo.CurrentCulture;

                        return CultureInfo.GetCultureInfo(name);
                    }

                    static string ToBcp47(string posix)
                    {
                        //
                        // Converts a POSIX-style locale string (e.g., "ff_CM.UTF-8@latin") to
                        // a BCP-47 compliant culture name (e.g., "ff-Latn-CM").
                        //

                        if (posix.AsSpan().IndexOfAny('.', '_', '@') < 0)
                            return posix;

                        // Format:
                        // language[_territory][.codeset][@modifier]
                        //
                        // en_IE.UTF-8@euro - full
                        // en_IE.UTF-8      - without modifier
                        // en_IE@euro       - without codeset
                        // en_IE            - minimal

                        var di = posix.IndexOf('.');
                        if (di < 0)
                            di = posix.Length;

                        var ai = posix.IndexOf('@');
                        if (ai < 0)
                            ai = posix.Length;

                        var name = posix.AsSpan(0, Math.Min(di, ai));
                        var modifier = posix.AsSpan(Math.Min(ai + 1, posix.Length));

                        if (!modifier.IsEmpty)
                        {
                            // Scripts
                            if (modifier.SequenceEqual("arabic")) modifier = "Arab";
                            else if (modifier.SequenceEqual("cyrillic")) modifier = "Cyrl";
                            else if (modifier.SequenceEqual("devanagari")) modifier = "Deva";
                            else if (modifier.SequenceEqual("latin")) modifier = "Latn";
                            // else if (modifier.SequenceEqual("adlam")) modifier = "Adlm";
                            // else if (modifier.SequenceEqual("bengali")) modifier = "Beng";
                            // else if (modifier.SequenceEqual("gurmukhi")) modifier = "Guru";
                            // else if (modifier.SequenceEqual("olchiki")) modifier = "Olck";
                            // else if (modifier.SequenceEqual("orya")) modifier = "odia" => "Orya";
                            // else if (modifier.SequenceEqual("telugu")) modifier = "Telu";
                            // else if (modifier.SequenceEqual("tifinagh")) modifier = "Tfng";
                            // else if (modifier.SequenceEqual("vai")) modifier = "Vaii";

                            // Variants
                            else if (modifier.SequenceEqual("valencia")) modifier = "valencia";
                            // skip
                            else
                                modifier = default;
                        }

                        var buffer = posix.Length > 32
                            ? new char[posix.Length]
                            : stackalloc char[32];

                        if (modifier.IsEmpty)
                        {
                            name.TryCopyTo(buffer);
                            buffer = buffer.Slice(0, name.Length);
                        }
                        else
                        {
                            //
                            // language-modifier-territory
                            //
                            var index = name.IndexOf('_');
                            if (index > 0 && modifier.Length == 4 && (uint)modifier[0] - 'A' <= 'Z' - 'A')
                            {
                                name.Slice(0, index).TryCopyTo(buffer);
                                buffer[index] = '-';

                                modifier.TryCopyTo(buffer.Slice(index + 1));
                                buffer[index + 1 + modifier.Length] = '-';

                                name.Slice(index + 1).TryCopyTo(buffer.Slice(index + 2 + modifier.Length));
                                buffer = buffer.Slice(0, name.Length + modifier.Length + 1);
                            }
                            else
                            {
                                //
                                // language-modifier
                                //
                                name.TryCopyTo(buffer);
                                buffer[name.Length] = '-';
                                modifier.TryCopyTo(buffer.Slice(name.Length + 1));
                                buffer = buffer.Slice(0, name.Length + 1 + modifier.Length);
                            }
                        }

                        #if NET8_0_OR_GREATER
                        buffer.Replace('_', '-');
                        #else
                        for (var i = 0; i < buffer.Length; i++)
                            if (buffer[i] == '_')
                                buffer[i] = '-';
                        #endif

                        posix = new string(buffer);
                        return posix;
                    }

                    static bool IsGlobalizationInvariant()
                    {
                        // https://github.com/dotnet/runtime/blob/8fafcb3251a3d2ccde36612a2eab47e9ae8ebe2b/src/libraries/System.Private.CoreLib/src/System/Globalization/GlobalizationMode.cs

                        if (AppContext.TryGetSwitch("System.Globalization.Invariant", out var isInvariant) && isInvariant)
                            return true;

                        var value = Environment.GetEnvironmentVariable("DOTNET_SYSTEM_GLOBALIZATION_INVARIANT");
                        if (value == "1" || string.Equals(value, "true", StringComparison.OrdinalIgnoreCase))
                            return true;

                        try
                        {
                            // Starting in .NET 6, creating or resolving cultures other than the invariant one
                            // throws an exception except when "PredefinedCulturesOnly" is set to false
                            // (in this case, NativeName contains "Invariant" for all returned cultures).
                            //
                            // https://learn.microsoft.com/en-us/dotnet/core/compatibility/globalization/6.0/culture-creation-invariant-mode
                            // https://learn.microsoft.com/en-us/dotnet/core/runtime-config/globalization#predefined-cultures

                            return CultureInfo.GetCultureInfo("en-US").NativeName.Contains("Invariant", StringComparison.Ordinal);
                        }
                        catch (CultureNotFoundException)
                        {
                            return true;
                        }
                    }
                }
            }

            """;

        context.AddSource("LocaleAlignment.g.cs", SourceText.From(source, Encoding.UTF8));
    }
}
